apply plugin: 'com.android.application'

android {
    def platform_id = project.hasProperty('PLATFORM') ? Integer.parseInt(PLATFORM) : 10076


    def info = getPackageInfo(platform_id)

    autoSign(info)
    def appName = info?info.app_name:"淘客云"
    compileSdkVersion 29
    buildToolsVersion "29.0.2"
    defaultConfig {
        applicationId info.app_id?info.app_id:"ceshi.taokeyun.cn"
        versionCode info.version_code?Integer.valueOf(info.version_code):1
        versionName info.version_name?info.version_name:"1.0.0"
        minSdkVersion 15
        targetSdkVersion 29
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig getSignInfo("../config/signs.properties",info)
        }
    }
    // applicationVariants are e.g. debug, release
    applicationVariants.all { variant ->
        variant.outputs.each { output ->
            // For each separate APK per architecture, set a unique version code as described here:
            // http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits
            def versionCodes = ["armeabi-v7a": 1, "x86": 2, "arm64-v8a": 3, "x86_64": 4]
            def abi = output.getFilter(com.android.build.OutputFile.ABI)
            if (abi != null) {  // null for the universal-debug, universal-release variants
                output.versionCodeOverride =
                        versionCodes.get(abi) * 1048576 + defaultConfig.versionCode
            }
            def outputPathName = "${project.rootDir}/release/${info.output_name}.apk"
            //output.outputFile = new File(outputPathName)
            def buildType = variant.buildType.name

            if (buildType == "release") {
                variant.getPackageApplication().outputDirectory = new File(project.rootDir.absolutePath + "/release/")
            }

            variant.outputs.all {
                if (variant.name.equalsIgnoreCase('release')){
                    outputFileName = "${info.platform}_${info.output_name}kong.apk"
                    //outputFileName = outputPathName

                }
            }

            /*
            def outputFile = output.outputFile
            def oldFileName = outputFile.name
            def newPath = "${project.rootDir}/release/"
            File newFile = new File(newPath)
            output.outputFile = new File(newFile,oldFileName)
            */
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'androidx.appcompat:appcompat:1.0.2'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    implementation 'com.google.android.material:material:1.0.0'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test:runner:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.1'
}


//自定义的Task
task kongbao {
// 这个task执行会在assembleDebug之后执行
    dependsOn 'assembleRelease'
    doLast {
        android.applicationVariants.all { variant ->
            variant.outputs.all { output ->

                //获取 apk打包出来的文件 output.outputFile
                if (variant.name.equalsIgnoreCase('release')) {
                    def name = output.outputFile.getName()
                    def checkfile = file("../release/${name}")
                    if (checkfile.exists()) {
                        println "打包成功！"
                        sendFinish(name)
                    }
                    else
                    {
                        println("打包失败！")
                    }
                }
            }
        }
    }
}
def autoSign(def info) {
    def MAIN_PATH = "/Users/alison/Desktop/app/buildonline/taokeyun/android"
    def keyfile=file("${MAIN_PATH}/config/${info.platform}_keystore.jks")
    def out = new ByteArrayOutputStream()
    if(!keyfile.exists() || info.newkey) {

        if (keyfile.exists()) {
            keyfile.delete()
        }
        //通过 exec {} 方式来执行命令
        def params = "keytool -genkey -v -alias ${info.alias_name} -dname CN=taokeyun,OU=taokeyun,O=taokeyun,L=zhangzhou,ST=Fujian,C=China -keyalg RSA -keysize 2048 -validity 365 -keypass ${info.key_pass} -keystore ${MAIN_PATH}/config/${info.platform}_keystore.jks -storepass ${info.store_pass}"
        println params

        //将命令的执行结果作为方法的返回值
        println params.execute().text
    }
    return out
}
def getSignInfo(propFileName,info) {
    def MAIN_PATH = "/Users/alison/Desktop/app/buildonline/taokeyun/android"
    def com.android.build.gradle.internal.dsl.SigningConfig signingConfig = new com.android.build.gradle.internal.dsl.SigningConfig("signInfo")
    File propFile = file(propFileName)
    if (propFile.exists()) {
        def Properties props = new Properties()
        props.load(new FileInputStream(propFile))
        signingConfig.v2SigningEnabled = true
        signingConfig.storeFile = file("${MAIN_PATH}/config/${info.platform}_keystore.jks")
        //signingConfig.storeFile = file("../config/taokehudong.keystore")
        signingConfig.storePassword = info.store_pass
        signingConfig.keyAlias = info.alias_name
        signingConfig.keyPassword = info.key_pass
        //println('signConfig is exits')
    } else {
        println('sign config is null')
        signingConfig = null
    }
    return signingConfig;
}

import groovy.json.JsonSlurper

def getPackageInfo(def platform) {
    //创建SSLContext对象，并使用我们指定的信任管理器初始化

/*
    TrustManager tm = new X509TrustManager() {

        @Override
        void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {

        }

        @Override
        void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {

        }

        @Override
        X509Certificate[] getAcceptedIssuers() {
            return null
        }
    }

    SSLContext sslContext = SSLContext.getInstance("SSL")
    sslContext.init(null, tm.getAcceptedIssuers(), new java.security.SecureRandom())

//从上述SSLContext对象中得到SSLSocketFactory对象
    SSLSocketFactory ssf = sslContext.getSocketFactory()

    HostnameVerifier hv= new HostnameVerifier(){

        @Override
        boolean verify(String s, SSLSession sslSession) {
            return true
        }
    }

    //请求的打包信息的服务器地址
    def urlString = "http://bd-pck.taokeyun.cn/pack.php?platform=${platform}"
    //def urlString = "https://dev-tk.taokeyun.online/public/tool/pack?type=android&platform_id=10091"
    println("request info from ${urlString}")
    def url = new URL(urlString)
    def packageInfoResult = null
    URLConnection conn = url.openConnection()
    if(conn instanceof HttpsURLConnection)
    {
        conn = (HttpsURLConnection)conn;
        conn.setSSLSocketFactory(ssf)
        conn.setHostnameVerifier(hv)
        conn.setRequestProperty("Accept-Encoding", "gzip, deflate, sdch")
    }
    else {
        conn = (HttpURLConnection)conn;
    }

    conn.setRequestMethod('GET')
    conn.setConnectTimeout(5000)
    int code = conn.getResponseCode()
    if(code == 200) {
        //请求成功
        InputStream is = conn.getInputStream()
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024]
        int len = 0
        while ((len = is.read(buffer)) != -1) {
            baos.write(buffer, 0, len)
        }
        baos.close()
        is.close()
        //转换数据
        byte[] byteArray = baos.toByteArray()
        def result = new String(byteArray)


        //def result = '{"appId":"com.taokeyun.app","versionName":"1.0.1","versionCode":1,"appName":"自定义名称"}'
        def JsonSlurper = new JsonSlurper()
        packageInfoResult = JsonSlurper.parseText(result)
        println packageInfoResult
    }
*/

   def packageInfoResult = null
   def jsonString = file('../config/json.properties').text
   def JsonSlurper = new JsonSlurper()
   packageInfoResult = JsonSlurper.parseText(jsonString)
    println packageInfoResult
    return packageInfoResult
}


import groovyx.net.http.*

import javax.net.ssl.HostnameVerifier
import javax.net.ssl.HttpsURLConnection
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSession
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.TrustManager
import javax.net.ssl.X509TrustManager
import java.security.cert.CertificateException
import java.security.cert.X509Certificate

def sendFinish(def filename){
    def finishurl="http://bd-pck.taokeyun.cn/kongbao.php?act=finish&fname=${filename}"
    println finishurl
    def http = new HTTPBuilder(finishurl)
    http.request(Method.GET ,ContentType.JSON) { req ->

        response.success = {resp,json->
            println resp.statusLine  //查看状态
            println resp.statusLine.statusCode == 200 //判断状态码是否为200
            println "Response length: ${resp.headers.'Content-Length'}"  //获取请求头
            println json
        }

        //404
        response.'404' = { resp ->
            println 'Not found'
        }

        // 401
        http.handler.'401' = { resp ->
            println "Access denied"
        }

        //其他错误，不实现则采用缺省的：抛出异常。
        http.handler.failure = { resp ->
            println "Unexpected failure: ${resp.statusLine}"
        }
    }

}

def downPic(def urlString,def picPath){
    try {
        def url = new URL(urlString);
        DataInputStream dataInputStream = new DataInputStream(url.openStream())
        def path = "${project.rootDir}/${picPath}"
        FileOutputStream fileOutputStream = new FileOutputStream(new File(path))
        ByteArrayOutputStream output = new ByteArrayOutputStream()

        byte[] buffer = new byte[1024]
        int length

        while ((length = dataInputStream.read(buffer)) > 0) {
            output.write(buffer, 0, length)
        }
        fileOutputStream.write(output.toByteArray())
        dataInputStream.close()
        fileOutputStream.close()
    } catch (MalformedURLException e) {
        e.printStackTrace()
    } catch (IOException e) {
        e.printStackTrace()
    }
}